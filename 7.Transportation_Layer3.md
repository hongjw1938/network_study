### Transportation Layer3
- Flow control
  - 이전에 배운 바에 따르면, TCP계층에서는 프로세스마다 Buffer를 가지기 때문에 Sender는 Receiver의 버퍼에 데이터를 전달시 window크기 만큼의 데이터만 보낸다. Receiver는 해당 데이터를 받아서 read process가 진행되면 application layer로 데이터를 올려보낸다.
  - Receiver는 그것을 위해서 자신의 buffer상태를 계속 피드백을 보낸다.
    - 어느 정도의 공간이 남아있는지를 알려주면 Sender는 그 이하로 데이터를 전달한다.
    - TCP Header 필드중에 Receiver Buffer라는 부분이 있기 때문에 그 부분에 남아 있는 용량을 계산해서 보낸다. 그러면 그 Header정보를 보고 Sender는 보낼 데이터 양을 결정
  - ![Alt text](/img/7-0.png)
    - Receiver는 위의 사진과 같이 free buffer space를 rwnd value를 통해서 TCP 헤더에 포함시켜 Sender에게 전달한다.
    - Sender는 receiver의 rwnd의 값에 맞추어 unacked data의 양을 제한하게 되어 receive buffer가 오버플로우 되지 않도록 보장한다.
  - 코너 케이스
    - rwnd =0 이라면?
      - 즉, 가득찬 상황이다. 남아 있는 공간이 없다. 그러면 Sender는 공간이 생길 때까지 데이터를 보내서는 안된다.
      - 그런데, 그 이후에 공간이 생겼음에도 Receiver는 세그먼트를 보낼 이유가 없으니까 Sender는 비었는지 안 비었는지 알 방도가 없다. 이러한 교착상태를 해결하기 위한 방법은 아래와 같다.
        - 상대에게 공간 있든 없든 그냥 세그먼트를 계속 날린다.(1byte만)
        - 그러면 receiver에 의해서 피드백이 오기 때문에 교착상태를 풀어낼 수 있다.
    - Silly window syndrome
      - 유저 프로세스가 보낼 데이터를 만드는 것이 느린 경우에, 원래 Sender는 버퍼에 차있는 내용 중에서 Max Segment Size(대략 530..?)만큼 계속 채워서 보내야 하는데, Buffer에 데이터가 얼마 없어서 바로 보내기가 애매한 경우가 있을 수 있다.
      - 또한 기다리면 너무 시간이 오래걸릴 수 있다. 이러한 문제를 해결하기 위해서
        - Nagle's algorithm
          - TCP는 우선 1바이트라도 Buffer에 데이터 있으면 세그먼트를 그냥 무조건 보낸다. 그 이후에 MSS가 다 차거나, ACK를 받기 전까지 데이터를 계속 채운다.
          - 즉, 다 안채워졌다고 해도 그냥 보내 버리는 것이다.
          - ACK를 받았다는 것은 다 채우지도 못했는데 네트워크가 매우 빠르다는 의미이므로 그냥 보내는 것이 낫다.(오버헤드가 크더라도)
        - Clark's solution
          - Receiver는 이러한 경우에 그냥 남아 있는 space가 0이라고 그냥 해버리는 것이다. 그러면 segment에 채울 때까지 보내지 않을 것이기 때문.
        - Delayed ACK
          - 버퍼가 세그먼트(MSS)보다 작은 경우일 때의 특수한 경우임
- Connection Management
  - 어떻게 시퀀스 넘버를 만들고, Buffer를 만들고 상호 트래킹을 하는지에 대한 기본적인 연결을 생성하는 방법에 대한 것.
  - 우선 데이터를 교환하기 전에, sender / receiver는 "handshake"를 진행한다.
    - 연결을 수행하는 과정이다.
    - 2-way handshake
      - sender가 request, receiver가 response
      - 그런데 이 방법은 문제가 있다. receiver가 response한 것에 대한 feedback이 없기 떄문이다. 그래서 연결이 제대로 수행되었는지 알 수 없다.
    - 3-way handshake
      - 양 쪽 모두 connection이 맺어졌다는 것을 확신하기 위해 진행하는 방식
      - ![Alt text](/img/7-1.png)
      - 이를 통해서 상호 시퀀스 번호를 보내면서 Connection을 하기 때문에 트래킹이 가능하다.
  - Closing Connection
    - 클라이언트가 데이터 보낼 것이 없으면 Fin segment를 보내게 된다. Receiver는 ACK를 보낸다.
    - 그러면 Receiver도 FIn을 보내고 Sender 도 ACK를 보내면서 연결이 끊기게 된다.
    - ![Alt text](/img/7-2.png)
      - 마지막에 Segment lifetime의 2배 정도로 waiting이 있는 이유는 마지막에 보내는 ACK가 유실될 수도 있기 때문이다. 
      - 만약 유실되게 된다면, 계속 Receiver가 FIN을 보내게 되니까 완벽하게 연결을 해제할 수 있도록 하기 위해서 잠시 동안의 시간간 대기하게 되는 것이다.
- Congestion Control
  - 이론적으로는 Flow control에 따라 상대 receiver에 buffer에 남아 있는 만큼 데이터 segment를 보낼 수 있을 것이다. 그런데, network의 병목현상이 있어서 상대 receiver가 받을 수 있는 양(예: 100kb)보다 훨씬 적은 양(예: 2kb)만 보낼 수 있다면 network에 맞추어서 보내야 한다.
  - 그래서, Receiver Buffer의 크기와 Network condition에 따라 둘을 비교해 최솟값만큼 보내야하는 것이다. 그런데 거의 대부분 요즘에는 메모리는 커서 문제가 없는데, Network condition이 문제가 되는 경우가 많아 그에 맞추어서 데이터를 전송하게 된다.
  - 또한, 네트워크 상태는 거의 대부분 flow를 가지기 때문에 그에 맞추어서 Sender의 buffer도 변화하게 되는 것이다.