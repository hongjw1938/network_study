### Transport Layer1
- 전송계층
  - 어플리케이션으로부터 데이터를 받아서 다른 어플리케이션으로 전송하는 역할을 함.
  - 위에 대한 논리적인 관계만 가진다. 그 아래에서 네트워크 계층으로 라우터가 연결되는 것.
  - 어플리케이션 프로세스에서는 메시지를 전달한다.
    - 이러한 메시지는 Segment에 들어가는데 이는 Header와 Data로 이루어진다. Segment는 Transport계층의 전송단위이다.(네트워크 계층은 Packet은 segment를 데이터로 가지고 추가적인 Header정보를 가진다.)
  - 프로토콜
    - TCP
      - 신뢰성을 가지며(보내는 메시지가 유실되거나 수정되지 않는다), 순서대로 도착한다.
      - congestion, flow control을 함. 즉, 흐름 제어함. 얼마만큼의 속도로 상대에게 전송할 것인지. 즉 상대가 받아볼 수 있는 수준으로 전달해야 한다는 부분을 맞추는 것.
      - congestion control은 현재 네트워크 상태를 확인해서 보낸다는 것이다. 예를 들어, 보내는 도중에 라우터가 매우 빡빡한 상황이면  데이터를 보내는 것이 매우 어려울 것이다. 이러한 부분을 제어해준다.
    - UDP
      - 신뢰성을 가지지 않음. 순서를 보장하지 않음.
      - 이외 제어를 하지 않음.
    - 프로토콜에서 delay에 대한 보장을 하지 않고 대역폭에 대한 보장을 하지 않는다.(이런 것은 어플리케이션에서 따로 구현해야 한다.)
  - Multiplexing / demultiplexing
    - multiplexing은 여러 군데에서 정보를 받아서 하나로 전달하는 것을 의미한다. 그 반대는 하나의 데이터를 여러 군데로 나누어 전달하는 것을 의미한다.
    - 즉, 여러 어플리케이션에서 소켓을 통해서 데이터를 보낼 것인데, 이것들은 모두 하나의 통로로 나갈 것이다. 보내는 측은 이렇고 리시버 쪽에서는 demultiplexing을 수행할 것이다. 이러한 과정은 전송계층에서 이루어진다.
    - demultiplexing을 할 때는 각 소켓으로 정보를 보내야 하기 때문에 이는 포트번호를 토대로 각 소켓으로 정보를 보낸다. 이 포트 번호는 전송계층의 헤더 정보에 포함된다. 소스 포트, 목적지 포트 번호가 있다.(이는 UDP도 들어있다.)
  - UDP의 demultiplexing
    - ![Alt text](/img/5-0.png)
    - 이와 같이 단순히 포트번호만으로 전송이 이루어지게 된다. 즉, 무조건 destination port번호만 보고 demultiplexing을 수행한다.
  - TCP의 demultiplexing?
    - source ip address
    - source port number
    - dest ip address
    - dest port number
    - 위 4가지 정보를 모두 참조해서 정보를 전달한다. 하나라도 다르면 다른 포트임.
    - ![Alt text](/img/5-1.png)
      - TCP 소켓은 1:1 대응이라는 것을 알 수 있다.
      - 실제로는 소켓은 하나만 만들고 요청이 오면 스레드를 만들어서 매핑을 해준다.
  - UDP
    - User Datagram Protocol이다.
    - 매우 가볍다. 대신 손실, 전달이 안되는 등의 문제가 있을 수 있다.
    - UDP는 멀티미디어 스트리밍 앱, DNS, SNMP등에 사용될 수 있다.
    - UDP의 헤더
      - ![Alt text](/img/5-2.png)
      - 소스 포트, 목적지 포트, 길이, checksum이 끝임.
      - 각 포트 번호는 de/multiplexing할 때 사용할 수 있다. checksum은 들어가는 정보가 변형이 되었는지 판단할 수 있는 데이터이다.(패리티 비트같은 것을 활용). checksum이 변형되었다면 에러가 난 데이터이므로 drop된다. 즉, 신뢰성은 없지만 전송 계층으로써 에러 검출은 가능하다는 것이다.
  - TCP
    - 신뢰성있는 데이터를 전송한다는 원칙을 가짐
    - 하위 계층은 unreliable하므로 여기서 모든 에러 검출을 다 해주어야 한다. 유실을 방지해야 한다. 
    - RDT(reliable data transfer) 프로토콜
      - 매우 단순한 조건하에서 작동한다. sender는 패킷을 보내고 receiver가 받았다는 100%확신이 있을 때만 다음 패킷을 보낸다.
      - 1.0 버젼
        - 만약 하위계층이 신뢰성이 있다면 따로 일을 할 필요가 없을 것이다. 비트 에러가 없고 패킷 유실이 없다. 그냥 보내면 된다. receiver는 받아서 데이터만 뽑아서 주면 된다.
      - 2.0 버젼
        - 하위 계층이 신뢰성이 없다면, 어떻게 에러를 회복시켜야 할까
        - 먼저 에러를 검출할 수 있어야한다.(checksum으로 한다.) 이에 따라서 ACK(acknowledgements : 리시버가 패킷을 받았다고 ok하는 것) 또는 NAK(negative ack : 리시버가 명백하게 못받았다고 알림)라는 feedback이 전송될 것이다.
        - NAK를 받았으면 재전송한다.
        - 그런데! 아직 치명적인 흠집이 있다.
        - 만약에, Sender가 피드백을 받았는데 그 피드백이 에러가 나면?? Sender는 무조건 재전송한다고 한다면, 원래 받았던 것과 같은 건지 아니면 새로운 것인지 Receiver가 알아야 할 것이다
      - 2.1버젼
        - 그것을 위한 장치가 바로 Sequence Number이다. 모든 패킷에 이것이 붙어있어서 이것이 새로운 패킷인지 아닌지를 확인할 수 있다.
        - 그러면 SN은 얼마나 사용해야 할까? 0 또는 1, 2개만 사용하면 된다. 즉 1비트. 같은 거면 0 아니면 1
      - 2.2버전
        - NAK가 없이 ACK만 사용해서 ACK에 담긴 SN만 가지고 제대로 받았는지 아닌지를 판단하는 것이다.
        - 무조건 ACK만 보내는데 여기에 SN을 담아서 보내는 것
