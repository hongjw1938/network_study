### Network Layer4
- Routing algorithm
  - 라우터는 알고리즘을 사용해서 라우팅테이블을 만든다. 이에 사용되는 알고리즘은 다음과 같다.
    - Link state algorithm : 3에서 공부한 내용
    - distance vector algorithm : 전체 링크 사이의 cost는 모르고 주변과 공유하면서 결국은 위의 알고리즘과 같은 내용을 만들게 됨
  - Link state
    - 다익스트라 알고리즘 사용
  - Distance vector
    - 벨만-포드 방정식(dynamic programming)사용
      - dx(y) = min{c(x,v) + dv(y)}
      - dx(y) : x에서 y까지의 최소거리를 나타내는 것.
      - c(x,v)는 x에서 도달가능한 여러 link중에서 하나인 v와의 cost를 의미한다.
      - 즉, 재귀적인 방식을 사용한 것
    - 기본적인 동작
      - 만약, x,y,z의 노드가 있다면 해당 노드들은 자기와 directly linked된 노드와의 cost만을 알고 있을 것이다.
      - 예) x to y : 4, x to z : 50, y to z : 1 이라면
      - x의 distance array는 0 4 50이 된다.
      - y는 4 0 1이 된다.
      - z는 50 1 0이 된다.
      - 이러한 내용들이 재귀적으로 이어지다가 서로의 라우터에게 내용이 전달되게 된다.
      - 즉, dx(y) = min(c(x,y)+dy(y), c(x,z)+dz(y))가 된다.
        - 전자의 내용은 4+0, 뒤는 50+1이므로 그를 통해 최종 path가 지정된다.
    - 링크 cost가 바뀌는 경우
      - y의 cost가 바뀌는 경우, y to x사이의 값이 변경. 근데 cost가 줄어들어서 개선된 경우는 테이블에 바로 반영되는데 cost가 크게 늘어서 나빠진 경우는 다르다.
      - 악화된 경우에는 direct link와 다른 루트를 통해 해당 노드에 도달하는 경우를 또 비교해서 더 나은 경우로 지정해야 한다.(ex y to x가 60이 되었다면, x -> z -> y가 더 빠르다.)
      - 근데 이것이 문제인 것이 아니라 만약 ,dz(x)가 5라면 y에게 해당 정보를 알려줄 것인데, 이러면 y는 자신을 통해서 가는 것인지, 아니면 다른 길을 통해서 가는 것인지 알아낼 방법이 없다. 그래서 알려줘버리면 오히려 혼란이 생길 수 있다.
      - 다른 곳을 통해서 하는거라면 상관 없는데 그 5라는 cost가 y를 통해서 하는 것이라면, y는 자신이 x에 직접 가게 되는 경우에 갑자기 그 코스트가 나빠졌다면 자신을 통해서 가는 것이라는 사실을 알 수 없으므로 다시 Z에게 해당 정보를 보내서 다른 길을 찾고자 하게 되는 것이다.
      - 그래서 z도 다시 해당 내용을 y에 보내게 되고 y도 다시 z에게 서로 노드 정보를 교환하면서 count to infinity 현상이 발생하게 된다. 즉, cost가 계속 증가하게됨.
      - ![Alt text](/img/12-0.png)
      - 해결책 : poison reverse
        - 해당 문제가 생긴 이유는 y를 이용한 cost임에도 불구하고 y 자신에게 cost 정보를 보내기 때문에 생기는 것.
        - 그래서 y한테는 최소한 해당 정보를 전달해선 안된다. 그래서 y한테는 해당 정보를 infinite 이라고 전달해야 한다. 그래서 더 카운팅하지 않게 된다.