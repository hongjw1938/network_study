### 2. Application Layer1
- Network app
- 어플리케이션(이메일, 휴대폰 앱 등등)을 실행시켜서 다른 어플리케이션 혹은 시스템과 통신하는 것.
- network core(router 등)이 어플리케이션을 동작시키지는 않는다.
- 소켓 프로그래밍을 하는 것. 소켓은 OS가 준비해둔 소프트웨어로 작성된 추상적 개념의 통선 접속점이다.
  - 소켓은 응용 프로그램(Application)에서 TCP/IP를 이용하는 창구 역할(인터페이스)을 한다. 클라이언트 어플리케이션은 서버와 통신을 하기 위해 어떠한 메시지 또는 데이터를 서버에 보내고자 한다. 이를 위해서는 네트워크에 연결하여 서버에 접속해야 하는데 이 때 소켓을 통해 접속한다.
  - 즉, 소켓으로 연결하면 서로 다른 프로세스끼리 데이터를 전달 할 수 있는데, 이 때, 서버로 연결하기 위해서 클라이언트 측에서는 서버의 IP 주소를 알아야 하고 특정 프로세스에 연결하기 위해 그 포트번호를 알아야 한다.
  - 보통 각 프로세스마다 개별 포트번호가 지정되어 있다. 웹 서버는 80번.
- 인터넷 전송 프로토콜 서비스
  - TCP
    - 신뢰성 있는 전송 프로토콜
    - 흐름 제어 / 혼잡 제어 등의 기능 수행
  - UDP
    - 신뢰성 없음. 흐름 제어, 혼잡 제어 드으이 기능을 하지 않음.
- 모델
  - Client-server 아키텍쳐
    - 서버는 항상 호스팅된다. 고정된 IP 주소를 가질 수 있다.
    - 클라이언트는 간헐적으로 필요시에만 서버에 연결. 고정된 IP 주소를 가질 필요가 없다.
- Web and HTTP
  - Web
    - web page는 object로 구성되어 있다. object는 HTML 파일, 이미지, applet, audio file등 다양하다. 각 object는 URL로 자원을 참조할 수 있다.
  - HTTP
    - Hypertext Transfer Protocol
    - 웹 어플리케이션 계층의 프로토콜이다. HyperText 정보를 전달하는 계층이다.
    - client-server 모델에서 client는 정보를 요청하고 server는 response(응답)한다.
    - TCP 전송계층을 사용한다. 신뢰성을 위해서
    - 서버 포트번호는 80번을 사용하도록 권장된다.
    - stateless, 즉 상태정보가 없는 프로토콜이다. 어떠한 상대 state에 대해 정보를 저장하지 않는다.
      - 상태를 기억하면 좋지 않을까?(stateless니까 이를 어떻게?)
        - HTTP는 cookie라는 트릭을 사용해서 customer를 기억하는 방법을 사용함.
        - Cookie
          - state를 저장함.
          - 예를 들어 아마존 서버에 접속하면 나라는 client의 정보를 저장해서 쿠키를 만든다.
          - 다시 접속하면 내가 접속했던 쿠키 정보가 남아있어서 그를 통해 사용자를 식별할 수 있다.
    - HTTP Connection
      - non-persistent
        - 하나의 오브젝트가 TCP 연결을 통해 전송되고 연결은 끊긴다. 즉, multiple connection
        - 아래는 Handshaking과정
        - 우선 URL로 연결을 한다면 TCP 연결을 만들기 위해 HTTP Client가 HTTP 서버로 connection을 시도한다.
        - HTTP server 호스트는 연결을 기다리다가 신호가 오면 accepts하여 connection을 수행하고 client에 알려준다.
        - client는 원하는 오브젝트의 정보가 담긴 request message를  TCP 연결 소켓으로 보낸다. 그러면, 서버에서 해당 request를 받고 요청받은 오브젝트가 들어있는 메세지를 만들어서 소켓으로 다시 전달한다.
        - 이 때, 서버는 TCP 연결을 끊는다. HTTP 클라이언트는 response message를 받고 html파일을 볼 수 있게 된다. 해당 HTML에 얼마나 object(reference)가 있느냐에 따라 이와 같은 과정이 N번 진행된다.
        - RTT(roud trip time) : 한 번 요청하고 응답하는 시간
      - persistent(지속적)
        - TCP를 하나 만들어놓고 계속 반복하여 사용함.
        - persistent는 non과는 달리 한 번 TCP가 연결되면 해당 html을 가져온 다음 TCP가 연결된 상태로 유지되기 때문에 object를 가져오기 위해서 재 연결을 시도할 필요는 없이 reference에 대한 request / response만 반복된다.
        - 이를 파이프라인 방식을 사용하면 N개의 request가 연속적으로 계속해서 요청되게 되어서 propagation delay를 감소시킬 수 있다.
    - HTTP message
      - 종류 : request / response의 두 개
      - message : ASCII 코드
      - general format : method / URL / version / header field name / value / entity body ... :: request line + header line + body
      - response message
        - status line(protocol status code, status phrase) + header line + data
      - response status code
        - 200(ok) / 301(moved permanently) / 400(bad request) / 404(not found) / 500(internal error)...
  - Web cache(proxy server)
    - 서버사이에 위치하여 클라이언트 대신 서버로 데이터를 요청함.
    - 서버로부터 가져온 오브젝트를 보관하다가 다른 클라이언트가 요청시에 서버에 가지 않고 그 오브젝트를 대신 제공해준다.
    - 장점
      - 속도가 빠르다.
      - 서버 입장에서는 작업 부하가 줄어든다.
      - 서버 관리 주체들의 경우 회선을 사용하는 경우가 줄어들어 비용이 줄어든다.
    - 단점
      - 중복성의 문제가 생김. origin server에 업데이트가 있는데, 프록시 서버에서 해당 server 내용을 가져오지 못하고 out-dated된 데이터를 저장하고 있을 수 있다.
      - 이를 해결하기 위해 Conditional-GET사용
    - Conditional-GET은 GET요청을 통해 request를 할 때, if-modified-since: <date>를 통해서 특정 date이후에 변경되었는지 아닌지 확인하는 것이다.
      - 만약 변경되었다면 200으로 변경되었다는 status가 전달되면서 데이터도 전달되며 변경되지 않았다면 304(Not Modified)로 전달될 것이다.
      - 즉, 프록시 서버가 자신이 가진 데이터가 최신인지 확인하기 위해 주기적으로 origin 서버에 요청하는 것이다.
