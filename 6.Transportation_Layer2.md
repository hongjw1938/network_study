### Transportation Layer2
- 이전의 내용에 이어서
  - rdt3.0
    - 패킷 유실이 없는 경우
      - receiver는 ack를 보낼 것이다.(SN=0)
      - 다시 Sender는 다음 내용을 보냄
    - 패킷 유실이 있는 경우
      - 보냈는데 Receiver로부터 아무런 연락이 없다면 도중에 유실된 것이다.
      - 이를 위해서 Timer가 세팅되어 있다. 이는 일정 시간이 지나면 유실됐다고 판단하고 동일한 내용을 재전송하는 방식으로 작동한다.
      - ![Alt text](/img/6-0.png)
      - Ack패킷이 유실된 경우
        - 이 경우에도 Timer에 의해 재전송한다. Receiver는 받게 되면 그것이 같은 것이라는 것을 안다. 그리고 다시 Sender에게 ack를 보낸다.
      - Ack패킷을 보내는데 오는 것보다 타이머가 더 빨리 켜진 경우
        - 그냥 다시 내용을 재전송하게 되고 Ack가 그 다음에 도착한다. 해당 Ack는 버린다. 
        - ![Alt text](/img/6-1.png)
    - 위의 경우가 stop-and-wait operation
      - 이렇게 하나 보내고 ack받고 하는 방식을 반복하는 것은 엄청난 비효율이 발생된다.
      - 그래서 파이프라인을 통해 여러개를 한꺼번에 보내고 ack도 한꺼번에 받는 방식을 사용한다.
      - 이 방식은 go-Back-N, selective repeat이라고 존재한다.
- TCP란
  - point-to-point방식이다.(하나의 sender, 하나의 receiver)
  - 신뢰성있고 순서대로 스트리밍된다.
  - pipeline을 통해 여러 패킷이 한번에 보내진다.
  - TCP segment 구조
    - ![Alt text](/img/6-2.png)
    - 포트번호는 멀티플렉싱에 사용.
    - SN은 Sender의 SN, Ack Number는 B의 SN이라고 보면 된다.
    - TCP연결을 할 때, Sender와 Receiver는 버퍼를 가지고 있다. TCP는 순서대로 패킷을 보내기 때문에, Buffer에 담아두고 해당 데이터를 전송하고 받는 방식을 사용한다. Sender는 전송하고 나서도 기존 패킷을 유지하다가 Receiver가 ACK를 보내서 받은게 확실하면 해당 패킷을 버퍼에서 버린다. Receiver는 버퍼에서 데이터를 쌓아두면서 순서를 유지하여 Application Layer로 올린다.
    - checksum은 에러 여부 확인. receive window는 receiver buffer에 어느 정도의 공간이 있는지를 알려주는 것이다. 만약 꽉 찼다면 더 보내면 안되니까.
    - 즉, TCP에서 사용하는 seq 번호는 byte번호이다. 제일 첫번 째 바이트 번호가 sequence 넘버이다.
    - ![Alt text](/img/6-3.png)
      - 이와 같이 Seq는 다음에 보낼 번호를 의미하는 것이다. Ack는 79이전까지 잘 받았다는 의미이기에 다음에 보낼 것은 79가 되는 것이다. 
      - 이와 같이 서로간에 상호 Seq를 트래킹하면서 패킷이 유실되는지 안되는지를 확인하고 순서대로 정보가 전달되는지 알 수 있는 것이다.
  - TCP round trip time, timeout
    - 어떻게 timeout 시간을 설정해야 할까?
    - round trip time을 실제로 TCP는 계속 측정한다. 그런데 이것은 항상 같지 않다. 경로가 다를 수 있지만 경로가 같더라도 queueing delay가 계속해서 변하기 때문에 RTT는 계속해서 변경되는 것이다.
    - 그래서, RTT값을 구하기 위해서 특정 식을 이용해서 최대한 일정하게 유지되도록 해당 시간값을 설정한다.
  - TCP Fast retransmission
    - ![Alt text](/img/6-4.png)
    - TCP는 파이프라인을 통해서 데이터 패킷을 보내는데, Receiver는 그것을 차례로 받을 것이다. 그런데.. 만약 위와 같이 92번 시퀀스 번호의 데이터를 보냈다고 가정하자. Receiver는 92번을 정확히 받았을 것이고 이에 대해 파이프라인으로 계속 정보가 올 것이니까 Ack를 그 때 마다 다 보내는 것은 비효율이므로 기다린다.
      - 실제로, RFC의 권장사항에서, Ack를 50mili sec정도 이후에 보내라는 사항 등이 있다. 왜냐하면, 파이프 라인으로 다 받았는데 그거에 대해 하나 하나 다 보내면 비효율이 크니까 마지막 받은 것에 대해서만 ack를 확인해주면 되기 때문이다.
    - 그 때, 일정시간안에 또 다른 패킷이 들어오면 ack를 보내지 않고 다음 패킷을 받는다. sequence number 100이 들어와야 하는데(이전에 92번이고 8바이트니까) 그런데 해당 번호는 들어오지 않고, 다음에 120번, 140번 등등으로 들어온다고 가정하자.
    - 그러면, Receiver는 100번을 못받았다고 Ack를 1번 보내게 되고, 120, 140번 등 그 뒤의 내용은 순서 유지를 위해 버퍼에 저장하게 된다. 근데 이 때, 100번을 못 받았다고 신호를 보냈음에도 계속 그 뒤의 패킷만 보내진다면 그 때도 계속 100번을 못 받았다는 ack를 보내게 된다.
    - 이 때, 최초로 못 받았다는 ack를 제외하고 동일한(duplicate) ack를 3번 연속으로 보내게 되면, Sender는 이 패킷이 유실되었다는 것을 그 때 파악하게 되고 다시 재전송하는 것이다.
    - 왜 이것이 fast냐면, 해당 3번의 중복 패킷이 timeout보다 짧기 때문이다. 즉, timeout시간이 지나서 100번을 못 받았다고 sender가 확신하기 이전에 3번의 중복 ack를 통해 못 받았다고 알 수 있기 때문에 fast retransmission이라고 부르는 것이다. TCP는 이와 같이 효율적으로 작동하기 위한 여러 장치가 있다.
